#!/usr/bin/env sh

# Common functions useful for scripts
#
# Changelog:
#   2016-10-09  Fix testing wrong fd in log()
#   2016-10-09  Fix critical => crit
#   2016-10-09  Add args_in function
#   2016-09-11  Fix assignment instead of defaulting on DEBUG and
#               funcdepth
#   2016-09-10  Add syslog-output log log()

# The MIT License (MIT)
# Copyright (c) 2016 Nelo-T. wallus <nelo@wallus.de>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# Logging function, prints to stderr or syslog
log() {
    level=$1
    leveltxt=$1
    shift

    # the lower the level the less output there is
    case $level in
        (crit)      level=0;;
        (warning)   level=10;;
        (info)      level=20;;
        (debug)     level=30;;
    esac

    if test "$level" -le ${DEBUG:-20}; then
        output=""
        if test -n "$SH_LOG_FULLPATH"; then
            output="${output}$0"
        else
            output="${output}$(basename $0)"
        fi
        output="${output}[$$]:"

        # FUNCNAME is not in the posix spec and afaik only implemented
        # in bash and zsh, but it provides useful information, so it's
        # added if available
        if test -n "$FUNCNAME"; then
            output="${output}${FUNCNAME[${funcdepth:-1}]}():"
        fi

        output="${output}${leveltxt}: $@"

        if test -n "$SH_LOG_SYSLOG" || ! test -t 2 ; then
            # -p is not posix-compliant but rfc5424-compliant and bloody
            # useful
            logger -p "${SH_LOG_SYSLOG:-local0}.$leveltxt" "$output"
        else
            echo $output >&2
        fi
    fi
}

die() {
    funcdepth=2 log crit "$@, aborting"
    exit ${errno:-1}
}

# calls die if the first arguments is not:
#   greater or equal to the second argument
#   smaller or equal to the third argument, if passed
args_in() {
    test $1 -ge $2 || die "${exit_message}Not enough arguments passed"

    if test $# -eq 3; then
        test $1 -le $3 || die "${exit_message}Too many arguments passed"
    fi
}

# useful function for wrappers
next_in_path() {
    log debug "Grabbing next path for $(basename $0)"
    PATH=$(echo $PATH | awk 'BEGIN { RS=":" ; ORS=":" } { if ("'$(dirname $0)'" != $0) { print $0 } }') command -v $(basename $0)
}

now() {
    date "+%Y-%m-%d %H:%M:%S:%s"
}
